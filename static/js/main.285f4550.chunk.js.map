{"version":3,"sources":["crypto/Header.js","crypto/Filter.js","crypto/CryptoItem.js","crypto/CryptoList.js","crypto/Crypto.js","App.js","serviceWorker.js","index.js"],"names":["Header","props","src","process","alt","className","rotate","Filter","type","placeholder","onChange","e","filterMethod","target","value","CryptoItem","arrows","up","String","fromCharCode","down","equal","data","buy","key","symbol","arrowSymbol","valueClass","status","CryptoList","list","map","item","index","Crypto","dataToArray","Object","keys","objectWithKey","getData","Axios","get","then","response","cryptoData","cryptoDataArray","setState","filteredCryptoData","isUpdated","filter","state","filterValue","tick","handleTick","setInterval","handleTick2","newFilteredArray","toUpperCase","includes","this","clearInterval","prevProps","prevState","cryptoDataWithStatus","i","length","Component","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.285f4550.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\nimport './css/Header.css'\r\n\r\nconst Header = (props) => {\r\n  // console.log(props.rotate);\r\n  const logo = process.env.PUBLIC_URL + 'BC_Logo.png'\r\n  return (\r\n    <header>\r\n      <img src={logo} alt=\"Crypto rate logo\" className={props.rotate ? 'rotate' : null} />\r\n      <h1>Crypto Rate</h1>\r\n    </header>);\r\n}\r\n\r\nexport default Header;","import React, { Component } from 'react';\r\nimport './css/Filter.css'\r\nconst Filter = (props) => {\r\n  return (\r\n    <input type=\"text\" placeholder=\"Filter\" onChange={(e) => props.filterMethod(e.target.value)} />\r\n  );\r\n}\r\n\r\nexport default Filter;","import React, { Component } from 'react';\r\nimport './css/CryptoItem.css'\r\nconst CryptoItem = (props) => {\r\n  const arrows = {\r\n    up: String.fromCharCode('8593'),\r\n    down: String.fromCharCode('8595'),\r\n    equal: String.fromCharCode('8596')\r\n  }\r\n  const { data: { buy, key, symbol, status } } = props;\r\n  let arrowSymbol = 'equal';\r\n  let valueClass = 'value '\r\n  switch (status) {\r\n    case 'equal': { arrowSymbol = arrows.equal; valueClass = 'value equal'; break };\r\n    case 'up': { arrowSymbol = arrows.up; valueClass = 'value up'; break; }\r\n    case 'down': { arrowSymbol = arrows.down; valueClass = 'value down'; break; }\r\n    default: arrowSymbol = ''\r\n  }\r\n\r\n\r\n  return (\r\n    <li className='crypto-item'>\r\n      <span className=\"title\">Last rate: </span>\r\n      <span className={valueClass}>{buy} {arrowSymbol}</span>\r\n      <span className=\"symbol\">{key} [{symbol}] </span>\r\n\r\n    </li>\r\n  );\r\n}\r\n\r\nexport default CryptoItem;","import React, { Component } from 'react';\r\nimport CryptoItem from './CryptoItem'\r\nimport './css/CryptoList.css'\r\n\r\nconst CryptoList = ({ data }) => {\r\n  const list = data.map((item, index) => <CryptoItem key={index} data={item} />)\r\n  return (\r\n    <ul className='crypto-list'>\r\n      {list}\r\n    </ul>\r\n  );\r\n}\r\n\r\nexport default CryptoList;","import React, { Component } from 'react';\r\nimport Header from './Header'\r\nimport Filter from './Filter';\r\nimport CryptoList from './CryptoList';\r\nimport Axios from 'axios'\r\nclass Crypto extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      cryptoData: [],\r\n      filteredCryptoData: [],\r\n      isUpdated: false,\r\n      filterValue: ''\r\n    }\r\n  }\r\n\r\n  dataToArray = (data) => {\r\n    const dataToArray = Object.keys(data).map(\r\n      (item) => {\r\n        let objectWithKey = data[item];\r\n        objectWithKey['key'] = item;\r\n        objectWithKey['status'] = 'equal'\r\n        return objectWithKey\r\n      })\r\n    return dataToArray\r\n  }\r\n\r\n  getData = () => {\r\n    Axios.get('https://blockchain.info/pl/ticker')\r\n      .then(response => {\r\n        const cryptoData = response.data;\r\n        const cryptoDataArray = this.dataToArray(cryptoData);\r\n\r\n        this.setState({ cryptoData: cryptoDataArray, filteredCryptoData: cryptoDataArray, isUpdated: true })\r\n        //jeśli jest już założony filtr - uwzględniej te wartość\r\n        this.filter(this.state.filterValue);\r\n      })\r\n  }\r\n\r\n  tick = () => {\r\n    this.handleTick = setInterval(\r\n      () => {\r\n        this.getData();\r\n      }, 5000\r\n    )\r\n    //to pewnie można rozwiązać dużo lepiej ?  \r\n    this.handleTick2 = setInterval(() => {\r\n      this.setState({ isUpdated: false })\r\n    }, 1000);\r\n  }\r\n\r\n  filter = (value) => {\r\n    let filteredItems = this.state.cryptoData;\r\n    let newFilteredArray = filteredItems.filter(item => {\r\n      return item.key.toUpperCase().includes(value.toUpperCase())\r\n    })\r\n    this.setState({ filteredCryptoData: newFilteredArray, filterValue: value })\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.tick();\r\n    this.getData();\r\n  }\r\n\r\n\r\n  componentWillUnmount() {\r\n    clearInterval(this.handleTick);\r\n    clearInterval(this.handleTick2);\r\n  }\r\n  componentDidUpdate(prevProps, prevState) {\r\n\r\n    //jeżeli poprzednia cena była inna od aktualnej zaktualizuj pole status [down,up,equal]\r\n    if (prevState.cryptoData !== this.state.cryptoData) {\r\n      const cryptoDataWithStatus = this.state.cryptoData;\r\n      for (let i = 0; i < prevState.cryptoData.length; i++) {\r\n        if (prevState.cryptoData[i].buy > this.state.cryptoData[i].buy) {\r\n          cryptoDataWithStatus[i]['status'] = 'down'\r\n        } else if (prevState.cryptoData[i].buy < this.state.cryptoData[i].buy) {\r\n          cryptoDataWithStatus[i]['status'] = 'up'\r\n        } else\r\n          cryptoDataWithStatus[i]['status'] = 'equal'\r\n      }\r\n      this.setState({ cryptoData: cryptoDataWithStatus })\r\n    }\r\n  }\r\n  render() {\r\n    return (\r\n      <>\r\n        <Header rotate={this.state.isUpdated} />\r\n        <Filter filterMethod={this.filter} />\r\n        <CryptoList data={this.state.filteredCryptoData} />\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Crypto;","import React from 'react';\r\nimport './App.css';\r\nimport Crypto from './crypto/Crypto'\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Crypto />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}